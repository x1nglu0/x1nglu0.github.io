<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>buuctf_day1</title>
    <link href="/2025/10/26/buuctf-day1/"/>
    <url>/2025/10/26/buuctf-day1/</url>
    
    <content type="html"><![CDATA[<h1 id="Buuctf-Writeup-Day1"><a href="#Buuctf-Writeup-Day1" class="headerlink" title="Buuctf Writeup - Day1"></a>Buuctf Writeup - Day1</h1><h2 id="1-test-your-nc"><a href="#1-test-your-nc" class="headerlink" title="1. test your nc"></a>1. test your nc</h2><p><strong>题目描述</strong>：一道简单的nc连接题。</p><p><strong>解题步骤</strong>：</p><ul><li>使用nc连接靶机</li><li>连接后直接执行<code>cat flag</code>即可获取flag</li></ul><h2 id="2-rip"><a href="#2-rip" class="headerlink" title="2. rip"></a>2. rip</h2><p><strong>题目描述</strong>：nc连接后什么都没有。</p><p><strong>解题步骤</strong>：</p><ul><li>用checksec发现no canary</li><li>file后发现是64位文件</li><li>放入IDA后发现有get函数</li></ul><p><img src="/image/buuctfday1/1.png"></p><p>get函数不会限制输入的字节数，于是我们想到栈溢出，用栈溢出来覆盖我们发现的<code>system(&quot;/bin/sh&quot;)</code>的地址。</p><p><img src="/image/buuctfday1/2.png"></p><p>栈溢出后覆盖到该地址即可获得系统权限。于是有exp：</p><p><img src="/image/buuctfday1/3.png"></p><p>运行后即可获得flag：</p><p><img src="/image/buuctfday1/4.png"></p><h2 id="3-warmup-csaw-2016-1"><a href="#3-warmup-csaw-2016-1" class="headerlink" title="3. warmup_csaw_2016_1"></a>3. warmup_csaw_2016_1</h2><p><strong>解题步骤</strong>：</p><ul><li>前面操作相同不再赘述</li><li>打开IDA后发现：</li></ul><p><img src="/image/buuctfday1/5.png"></p><p>有get函数还发现了cat flag：</p><p><img src="/image/buuctfday1/6.png"></p><p>那我们一样栈溢出后覆盖地址到cat flag前的push地址即可。于是有以下exp：</p><p><img src="/image/buuctfday1/7.png"></p><p>运行即可得到flag：</p><p><img src="/image/buuctfday1/8.png"></p><h2 id="4-ciscn-2019-n-1"><a href="#4-ciscn-2019-n-1" class="headerlink" title="4. ciscn_2019_n_1"></a>4. ciscn_2019_n_1</h2><p><strong>解题步骤</strong>：</p><ul><li>checksec后发现no canary</li><li>file后发现是64位文件</li><li>放入64位IDA后查看main函数：</li></ul><p><img src="/image/buuctfday1/9.png"></p><p>发现它先让v2&#x3D;0.0，有一个条件判断，我们只要让v2&#x3D;11.28125即可执行cat flag获得flag。于是我们想到栈溢出，栈溢出不仅可以覆盖地址，还可以覆盖变量值，我们可以通过栈溢出覆盖v2，使其变为11.28125即可获得flag。</p><p>注：11.28125在64位中为41348000</p><p>于是有exp：</p><p><img src="/image/buuctfday1/10.png"></p><p>运行后即可获得flag：</p><p><img src="/image/buuctfday1/11.png"></p><h2 id="5-pwn1-sctf-2016"><a href="#5-pwn1-sctf-2016" class="headerlink" title="5. pwn1_sctf_2016"></a>5. pwn1_sctf_2016</h2><p><strong>解题步骤</strong>：</p><ul><li>打开IDA后分析：</li></ul><p><img src="/image/buuctfday1/12.png"></p><p>replace函数将”I”替换为”you”（从1字节变为3字节），通过字符逃逸实现栈溢出。fgets有限制输入字节数，但通过字符替换可以增加字节数目。</p><p>查看s的偏移量：</p><p><img src="/image/buuctfday1/13.png"></p><p>得出偏移量为03c+4&#x3D;0x40&#x3D;64个字节。</p><p>找到cat flag调用的地址：</p><p><img src="/image/buuctfday1/14.png"></p><p>构造exp（限制23字节）：</p><p><img src="/image/buuctfday1/15.png"></p><p>运行后即可获得flag：</p><p><img src="/image/buuctfday1/16.png"></p><h2 id="6-jarvisoj-level0-1"><a href="#6-jarvisoj-level0-1" class="headerlink" title="6. jarvisoj_level0_1"></a>6. jarvisoj_level0_1</h2><p><strong>解题步骤</strong>：</p><ul><li>打开IDA后查看callsystem函数：</li></ul><p><img src="/image/buuctfday1/17.png"></p><p>得到系统调用的地址。</p><p>查看main函数：</p><p><img src="/image/buuctfday1/18.png"></p><p>是一个明显的栈溢出，读取200字节。通过简单栈溢出覆盖到系统调用地址即可，于是有exp：</p><p><img src="/image/buuctfday1/19.png"></p><p>运行后即可获得flag：</p><p><img src="/image/buuctfday1/20.png"></p><h2 id="7-第五空间2019决赛-PWN5"><a href="#7-第五空间2019决赛-PWN5" class="headerlink" title="7. 第五空间2019决赛 PWN5"></a>7. 第五空间2019决赛 PWN5</h2><p><strong>解题步骤</strong>：</p><ul><li>checksec后发现与之前截然不同的结果：有canary保护</li><li>需要想办法绕过canary保护</li><li>查看main函数：</li></ul><p><img src="/image/buuctfday1/21.png"></p><p>发现它先生成一个随机数（4字节），如果输入与随机数相同，即可获得flag。可以发现read可以栈溢出，可以通过栈溢出改变随机数从而通过if函数，这就要绕过canary保护。</p><p><strong>Canary保护原理</strong>：是一种用于防护栈溢出的安全机制。其基本原理是在函数调用时，在栈帧的上方放入一个随机值（称为”Canary”），当函数返回时，系统会检查这个随机值是否被修改。如果随机值被修改，说明可能发生了栈溢出，程序将终止运行，从而防止潜在的缓冲区溢出攻击。</p><ul><li>找到canary的偏移量：</li></ul><p><img src="/image/buuctfday1/22.png"></p><ul><li>编写exp：</li></ul><p><img src="/image/buuctfday1/23.png"></p><p>注：特别要注意的是<code>%n</code>这个格式化字符串，它的功能是将<code>%n</code>之前打印出来的字符个数（四字节）写入参数地址处（赋值给一个变量）。</p><ul><li>运行后即可获得flag：</li></ul><p><img src="/image/buuctfday1/24.png"></p><h2 id="8-jarvisoj-level2"><a href="#8-jarvisoj-level2" class="headerlink" title="8. jarvisoj_level2"></a>8. jarvisoj_level2</h2><p><strong>解题步骤</strong>：</p><ul><li>同样的步骤之后查看main函数：</li></ul><p><img src="/image/buuctfday1/25.png"></p><p>发现明显栈溢出。但发现system函数调用和<code>/bin/sh</code>是分隔的。于是要把它们连接。</p><p>注：32位的分布是：返回地址+下一次的返回地址+参数1+参数2+…，这里返回地址可以随便指定。</p><ul><li>编写exp：</li></ul><p><img src="/image/buuctfday1/26.png"></p><p>运行后即可获得flag。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2libc</title>
    <link href="/2025/10/04/ret2libc/"/>
    <url>/2025/10/04/ret2libc/</url>
    
    <content type="html"><![CDATA[<h1 id="ret2libc技术总结"><a href="#ret2libc技术总结" class="headerlink" title="ret2libc技术总结"></a>ret2libc技术总结</h1><h2 id="1-32位与64位程序函数传参差异"><a href="#1-32位与64位程序函数传参差异" class="headerlink" title="1. 32位与64位程序函数传参差异"></a>1. 32位与64位程序函数传参差异</h2><h3 id="1-1-32位程序传参方式"><a href="#1-1-32位程序传参方式" class="headerlink" title="1.1 32位程序传参方式"></a>1.1 32位程序传参方式</h3><ul><li><strong>传参方式</strong>：通过栈传参，属于后传参</li><li><strong>典型payload结构</strong>：<br>p32(puts_plt) + p32(main_addr) + p32(puts_got)</li></ul><h3 id="1-2-64位程序传参方式"><a href="#1-2-64位程序传参方式" class="headerlink" title="1.2 64位程序传参方式"></a>1.2 64位程序传参方式</h3><ul><li><strong>传参方式</strong>：通过寄存器传参，参数从左到右依次放入寄存器：rdi, rsi, rdx, rcx, r8, r9</li><li><strong>典型payload结构</strong>：<br>p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</li></ul><h2 id="2-Write函数在ret2libc中的应用"><a href="#2-Write函数在ret2libc中的应用" class="headerlink" title="2. Write函数在ret2libc中的应用"></a>2. Write函数在ret2libc中的应用</h2><h3 id="2-1-Write函数参数说明"><a href="#2-1-Write函数参数说明" class="headerlink" title="2.1 Write函数参数说明"></a>2.1 Write函数参数说明</h3><ul><li><strong>第一个参数</strong>：文件描述符（0-标准输入，1-标准输出，2-标准错误）</li><li><strong>第二个参数</strong>：要泄露地址的函数的GOT表</li><li><strong>第三个参数</strong>：输出的字节数（32位为4字节，64位为8字节）</li></ul><h3 id="2-2-32位Write函数传参"><a href="#2-2-32位Write函数传参" class="headerlink" title="2.2 32位Write函数传参"></a>2.2 32位Write函数传参</h3><p>p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)</p><h3 id="2-3-64位Write函数传参"><a href="#2-3-64位Write函数传参" class="headerlink" title="2.3 64位Write函数传参"></a>2.3 64位Write函数传参</h3><p>p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(write_got) + p64(rdx_addr) + p64(8) + p64(write_plt) + p64(main_addr)</p><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><ol><li><strong>参数复用</strong>：传参时有时可以直接利用程序中已有的参数，避免额外构造</li><li><strong>第三个参数灵活性</strong>：当第三个参数由rsi与其他寄存器一起出现时，可以适当简化</li><li><strong>输出描述符选择</strong>：标准输出(1)和标准错误(2)都可以用作write函数的第一个参数</li><li><strong>寄存器使用顺序</strong>：64位系统中必须严格按照rdi→rsi→rdx→rcx→r8→r9的顺序传参</li></ol><h2 id="4-技术要点"><a href="#4-技术要点" class="headerlink" title="4. 技术要点"></a>4. 技术要点</h2><ul><li>正确识别目标程序的位数（32位&#x2F;64位）</li><li>准确获取所需函数的PLT和GOT表地址  </li><li>合理构造ROP链，确保参数传递正确</li><li>注意栈对齐和函数调用约定</li></ul>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canary绕过</title>
    <link href="/2025/10/03/canary%E7%BB%95%E8%BF%87/"/>
    <url>/2025/10/03/canary%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<p><strong>1.通过确认偏移(偏移&#x3D;变量自身偏移+变量到canary的偏移)来利用输出函数达到泄露canary的值：</strong><br>(1).64位：%n$p<br>(2).32位：%n$x<br><strong>注意：%n$p是泄露偏移为n的栈上的数据，%n$s是泄露偏移为n的栈上的地址的值(该偏移对应的栈上的数据必须是地址)。</strong></p><p><strong>2.通过溢出来利用输出函数泄露canary的值：</strong><br>**(1).**payload&#x3D;b’a’*offset+b’b’*0x1(注意send送，因为sendline会多发一个\n)<br>p.recvuntil(b’b’)<br>32位：canary&#x3D;u32(p.recv(3).rjust(4,b’\x00’))<br>64位：canary&#x3D;u64(p.recv(7).rjust(8,b’\x00’))</p><p>**(2).**利用sendline的特性：<br>payload&#x3D;b’a’*offset(注意用sendline发送)<br>p.recvuntil(b’a’*offset)<br>canary&#x3D;u32(p.recv(4))-0xa(减0xa是为了把sendline发送的换行符\n减掉)</p><p><strong>利用gdb调试</strong><br>**1.**随便在canary设置完的地方下断点<br>**2.**输入canary查找canary的值以及所在地址<br>**3.**stack 50找到该地址，计算偏移：<br><img src="/image/canary1.png" alt="gdb调试寻找偏移"></p><p>因为是六十四位文件所以他格式化字符串时候前六个参数是在寄存器中的而栈空间这个记录的第一个偏移其实是真实的第七个数据单元所以这边算出来还要再加6，即为canary值。<br>上图偏移就为184&#x2F;8&#x3D;23。23+6&#x3D;29。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
