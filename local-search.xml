<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ret2libc</title>
    <link href="/2025/10/04/ret2libc/"/>
    <url>/2025/10/04/ret2libc/</url>
    
    <content type="html"><![CDATA[<h1 id="ret2libc技术总结"><a href="#ret2libc技术总结" class="headerlink" title="ret2libc技术总结"></a>ret2libc技术总结</h1><h2 id="1-32位与64位程序函数传参差异"><a href="#1-32位与64位程序函数传参差异" class="headerlink" title="1. 32位与64位程序函数传参差异"></a>1. 32位与64位程序函数传参差异</h2><h3 id="1-1-32位程序传参方式"><a href="#1-1-32位程序传参方式" class="headerlink" title="1.1 32位程序传参方式"></a>1.1 32位程序传参方式</h3><ul><li><strong>传参方式</strong>：通过栈传参，属于后传参</li><li><strong>典型payload结构</strong>：<br>p32(puts_plt) + p32(main_addr) + p32(puts_got)</li></ul><h3 id="1-2-64位程序传参方式"><a href="#1-2-64位程序传参方式" class="headerlink" title="1.2 64位程序传参方式"></a>1.2 64位程序传参方式</h3><ul><li><strong>传参方式</strong>：通过寄存器传参，参数从左到右依次放入寄存器：rdi, rsi, rdx, rcx, r8, r9</li><li><strong>典型payload结构</strong>：<br>p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</li></ul><h2 id="2-Write函数在ret2libc中的应用"><a href="#2-Write函数在ret2libc中的应用" class="headerlink" title="2. Write函数在ret2libc中的应用"></a>2. Write函数在ret2libc中的应用</h2><h3 id="2-1-Write函数参数说明"><a href="#2-1-Write函数参数说明" class="headerlink" title="2.1 Write函数参数说明"></a>2.1 Write函数参数说明</h3><ul><li><strong>第一个参数</strong>：文件描述符（0-标准输入，1-标准输出，2-标准错误）</li><li><strong>第二个参数</strong>：要泄露地址的函数的GOT表</li><li><strong>第三个参数</strong>：输出的字节数（32位为4字节，64位为8字节）</li></ul><h3 id="2-2-32位Write函数传参"><a href="#2-2-32位Write函数传参" class="headerlink" title="2.2 32位Write函数传参"></a>2.2 32位Write函数传参</h3><p>p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)</p><h3 id="2-3-64位Write函数传参"><a href="#2-3-64位Write函数传参" class="headerlink" title="2.3 64位Write函数传参"></a>2.3 64位Write函数传参</h3><p>p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(write_got) + p64(rdx_addr) + p64(8) + p64(write_plt) + p64(main_addr)</p><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><ol><li><strong>参数复用</strong>：传参时有时可以直接利用程序中已有的参数，避免额外构造</li><li><strong>第三个参数灵活性</strong>：当第三个参数由rsi与其他寄存器一起出现时，可以适当简化</li><li><strong>输出描述符选择</strong>：标准输出(1)和标准错误(2)都可以用作write函数的第一个参数</li><li><strong>寄存器使用顺序</strong>：64位系统中必须严格按照rdi→rsi→rdx→rcx→r8→r9的顺序传参</li></ol><h2 id="4-技术要点"><a href="#4-技术要点" class="headerlink" title="4. 技术要点"></a>4. 技术要点</h2><ul><li>正确识别目标程序的位数（32位&#x2F;64位）</li><li>准确获取所需函数的PLT和GOT表地址  </li><li>合理构造ROP链，确保参数传递正确</li><li>注意栈对齐和函数调用约定</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>canary绕过</title>
    <link href="/2025/10/03/canary%E7%BB%95%E8%BF%87/"/>
    <url>/2025/10/03/canary%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<p><strong>1.通过确认偏移(偏移&#x3D;变量自身偏移+变量到canary的偏移)来利用输出函数达到泄露canary的值：</strong><br>(1).64位：%n$p<br>(2).32位：%n$x<br><strong>注意：%n$p是泄露偏移为n的栈上的数据，%n$s是泄露偏移为n的栈上的地址的值(该偏移对应的栈上的数据必须是地址)。</strong></p><p><strong>2.通过溢出来利用输出函数泄露canary的值：</strong><br>**(1).**payload&#x3D;b’a’*offset+b’b’*0x1(注意send送，因为sendline会多发一个\n)<br>p.recvuntil(b’b’)<br>32位：canary&#x3D;u32(p.recv(3).rjust(4,b’\x00’))<br>64位：canary&#x3D;u64(p.recv(7).rjust(8,b’\x00’))</p><p>**(2).**利用sendline的特性：<br>payload&#x3D;b’a’*offset(注意用sendline发送)<br>p.recvuntil(b’a’*offset)<br>canary&#x3D;u32(p.recv(4))-0xa(减0xa是为了把sendline发送的换行符\n减掉)</p><p><strong>利用gdb调试</strong><br>**1.**随便在canary设置完的地方下断点<br>**2.**输入canary查找canary的值以及所在地址<br>**3.**stack 50找到该地址，计算偏移：<br><img src="/image/canary1.png" alt="gdb调试寻找偏移"></p><p>因为是六十四位文件所以他格式化字符串时候前六个参数是在寄存器中的而栈空间这个记录的第一个偏移其实是真实的第七个数据单元所以这边算出来还要再加6，即为canary值。<br>上图偏移就为184&#x2F;8&#x3D;23。23+6&#x3D;29。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
