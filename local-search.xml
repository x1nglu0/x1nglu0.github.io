<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pwn的部分堆题复现</title>
    <link href="/2025/10/28/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/"/>
    <url>/2025/10/28/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-hitcontraining-heapcreator"><a href="#1-hitcontraining-heapcreator" class="headerlink" title="1. hitcontraining_heapcreator"></a>1. hitcontraining_heapcreator</h2><h3 id="保护机制检查"><a href="#保护机制检查" class="headerlink" title="保护机制检查"></a>保护机制检查</h3><p><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/1.png"></p><h3 id="主函数分析"><a href="#主函数分析" class="headerlink" title="主函数分析"></a>主函数分析</h3><p><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/2.png"></p><h3 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h3><p>查看各个函数，发现漏洞在edit函数：<br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/3.png"></p><p>可以看到函数可以多覆盖一位，存在off-by-one漏洞。edit时可以多写入一个字节，通过溢出覆盖下一个chunk的size字段。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>程序存在复用机制，如果chunk都处于inuse状态，上一个chunk可以使用到下一个chunk的prev_size</li><li>通过溢出修改下一个chunk的size字段</li><li>修改size为0x41后free，可以一次性free掉两个堆块</li><li>重新申请0x30大小的堆块，完成堆内容堆块和堆指针堆块的互换</li><li>修改堆指针堆块内容泄露libc版本（通过free_got）</li><li>将free函数跳转为system函数</li><li>free掉heap0触发system(“&#x2F;bin&#x2F;sh”)获取shell</li></ul><h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><p>创建两个堆块：<br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/4.png"></p><p>修改size为0x41：<br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/5.png"></p><p>free后重新申请：<br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/6.png"><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/7.png"><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/8.png"></p><p>查看libc偏移：<br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/9.png"></p><h3 id="EXP代码"><a href="#EXP代码" class="headerlink" title="EXP代码"></a>EXP代码</h3><p><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/10.png"></p><h3 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h3><p><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/11.png"></p><hr><h2 id="2-hitcon2014-stkof"><a href="#2-hitcon2014-stkof" class="headerlink" title="2. hitcon2014_stkof"></a>2. hitcon2014_stkof</h2><h3 id="保护机制检查-1"><a href="#保护机制检查-1" class="headerlink" title="保护机制检查"></a>保护机制检查</h3><p><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/12.png"></p><h3 id="主函数分析-1"><a href="#主函数分析-1" class="headerlink" title="主函数分析"></a>主函数分析</h3><p><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/13.png"><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/14.png"></p><h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3><p><strong>选择1（创建堆块）：</strong><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/15.png"></p><ul><li>创建堆块并打印内容</li><li>将堆块的data指针存放到dword_602100地址</li></ul><p><strong>选择2（编辑堆块）：</strong><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/16.png"></p><ul><li>可输入任意大小，存在堆溢出漏洞</li></ul><p><strong>选择3（释放堆块）：</strong><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/17.png"></p><ul><li>free函数，指针清零，无UAF漏洞</li></ul><p><strong>选择4：</strong><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/18.png"></p><ul><li>无实际功能</li></ul><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>创建3个堆块进行观察：<br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/19.png"></p><p>发现chunk2和chunk3相邻，可以通过edit修改chunk2内容溢出到chunk3：<br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/20.png"><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/21.png"></p><p><strong>利用条件：</strong></p><ul><li>关闭PIE保护</li><li>存在堆溢出漏洞</li><li>知道堆块指针存放位置</li></ul><p><strong>利用步骤：</strong></p><ol><li>在chunk2的data部分伪造fake_chunk</li><li>通过堆溢出修改chunk3的prev_size和size的P标志位</li><li>释放chunk3时触发向前合并，触发unlink</li><li>泄露libc版本并修改函数地址</li></ol><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><p><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/22.png"></p><hr><h2 id="3-hitcontraining-uaf"><a href="#3-hitcontraining-uaf" class="headerlink" title="3. hitcontraining_uaf"></a>3. hitcontraining_uaf</h2><h3 id="保护机制检查-2"><a href="#保护机制检查-2" class="headerlink" title="保护机制检查"></a>保护机制检查</h3><p><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/23.png"></p><h3 id="主函数分析-2"><a href="#主函数分析-2" class="headerlink" title="主函数分析"></a>主函数分析</h3><p><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/24.png"></p><h3 id="功能分析-1"><a href="#功能分析-1" class="headerlink" title="功能分析"></a>功能分析</h3><p><strong>add函数：</strong><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/25.png"></p><ul><li>创建两个堆块</li><li>第一个堆块存储puts函数和content内容地址</li><li>第二个堆块存储content内容</li></ul><p><strong>delete函数：</strong><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/26.png"></p><ul><li>存在UAF漏洞，指针未清零</li></ul><p><strong>print函数：</strong><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/27.png"></p><ul><li>跳转到第一个堆块存储的puts函数地址</li></ul><p><strong>magic函数（后门）：</strong><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/28.png"></p><ul><li>直接获取shell的后门函数</li></ul><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>创建两个堆块观察：<br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/29.png"></p><p><strong>利用步骤：</strong></p><ol><li>利用UAF漏洞和堆块复用机制</li><li>free掉堆块后创建较小堆块复用之前的堆块结构</li><li>修改第一个堆块的puts函数地址为magic函数地址</li><li>调用print(0)触发magic函数获取shell</li></ol><h3 id="调试过程-1"><a href="#调试过程-1" class="headerlink" title="调试过程"></a>调试过程</h3><p>修改puts地址为magic地址：<br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/30.png"><br><img src="/image/pwn%E7%9A%84%E9%83%A8%E5%88%86%E5%A0%86%E9%A2%98%E5%A4%8D%E7%8E%B0/31.png"></p><p><strong>注意：</strong> 需要print第一个堆块(print 0)来触发</p><hr><p>本文到此结束！</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buuctf_day1</title>
    <link href="/2025/10/26/buuctf-day1/"/>
    <url>/2025/10/26/buuctf-day1/</url>
    
    <content type="html"><![CDATA[<h1 id="Buuctf-Writeup-Day1"><a href="#Buuctf-Writeup-Day1" class="headerlink" title="Buuctf Writeup - Day1"></a>Buuctf Writeup - Day1</h1><h2 id="1-test-your-nc"><a href="#1-test-your-nc" class="headerlink" title="1. test your nc"></a>1. test your nc</h2><p><strong>题目描述</strong>：一道简单的nc连接题。</p><p><strong>解题步骤</strong>：</p><ul><li>使用nc连接靶机</li><li>连接后直接执行<code>cat flag</code>即可获取flag</li></ul><h2 id="2-rip"><a href="#2-rip" class="headerlink" title="2. rip"></a>2. rip</h2><p><strong>题目描述</strong>：nc连接后什么都没有。</p><p><strong>解题步骤</strong>：</p><ul><li>用checksec发现no canary</li><li>file后发现是64位文件</li><li>放入IDA后发现有get函数</li></ul><p><img src="/image/buuctfday1/1.png"></p><p>get函数不会限制输入的字节数，于是我们想到栈溢出，用栈溢出来覆盖我们发现的<code>system(&quot;/bin/sh&quot;)</code>的地址。</p><p><img src="/image/buuctfday1/2.png"></p><p>栈溢出后覆盖到该地址即可获得系统权限。于是有exp：</p><p><img src="/image/buuctfday1/3.png"></p><p>运行后即可获得flag：</p><p><img src="/image/buuctfday1/4.png"></p><h2 id="3-warmup-csaw-2016-1"><a href="#3-warmup-csaw-2016-1" class="headerlink" title="3. warmup_csaw_2016_1"></a>3. warmup_csaw_2016_1</h2><p><strong>解题步骤</strong>：</p><ul><li>前面操作相同不再赘述</li><li>打开IDA后发现：</li></ul><p><img src="/image/buuctfday1/5.png"></p><p>有get函数还发现了cat flag：</p><p><img src="/image/buuctfday1/6.png"></p><p>那我们一样栈溢出后覆盖地址到cat flag前的push地址即可。于是有以下exp：</p><p><img src="/image/buuctfday1/7.png"></p><p>运行即可得到flag：</p><p><img src="/image/buuctfday1/8.png"></p><h2 id="4-ciscn-2019-n-1"><a href="#4-ciscn-2019-n-1" class="headerlink" title="4. ciscn_2019_n_1"></a>4. ciscn_2019_n_1</h2><p><strong>解题步骤</strong>：</p><ul><li>checksec后发现no canary</li><li>file后发现是64位文件</li><li>放入64位IDA后查看main函数：</li></ul><p><img src="/image/buuctfday1/9.png"></p><p>发现它先让v2&#x3D;0.0，有一个条件判断，我们只要让v2&#x3D;11.28125即可执行cat flag获得flag。于是我们想到栈溢出，栈溢出不仅可以覆盖地址，还可以覆盖变量值，我们可以通过栈溢出覆盖v2，使其变为11.28125即可获得flag。</p><p>注：11.28125在64位中为41348000</p><p>于是有exp：</p><p><img src="/image/buuctfday1/10.png"></p><p>运行后即可获得flag：</p><p><img src="/image/buuctfday1/11.png"></p><h2 id="5-pwn1-sctf-2016"><a href="#5-pwn1-sctf-2016" class="headerlink" title="5. pwn1_sctf_2016"></a>5. pwn1_sctf_2016</h2><p><strong>解题步骤</strong>：</p><ul><li>打开IDA后分析：</li></ul><p><img src="/image/buuctfday1/12.png"></p><p>replace函数将”I”替换为”you”（从1字节变为3字节），通过字符逃逸实现栈溢出。fgets有限制输入字节数，但通过字符替换可以增加字节数目。</p><p>查看s的偏移量：</p><p><img src="/image/buuctfday1/13.png"></p><p>得出偏移量为03c+4&#x3D;0x40&#x3D;64个字节。</p><p>找到cat flag调用的地址：</p><p><img src="/image/buuctfday1/14.png"></p><p>构造exp（限制23字节）：</p><p><img src="/image/buuctfday1/15.png"></p><p>运行后即可获得flag：</p><p><img src="/image/buuctfday1/16.png"></p><h2 id="6-jarvisoj-level0-1"><a href="#6-jarvisoj-level0-1" class="headerlink" title="6. jarvisoj_level0_1"></a>6. jarvisoj_level0_1</h2><p><strong>解题步骤</strong>：</p><ul><li>打开IDA后查看callsystem函数：</li></ul><p><img src="/image/buuctfday1/17.png"></p><p>得到系统调用的地址。</p><p>查看main函数：</p><p><img src="/image/buuctfday1/18.png"></p><p>是一个明显的栈溢出，读取200字节。通过简单栈溢出覆盖到系统调用地址即可，于是有exp：</p><p><img src="/image/buuctfday1/19.png"></p><p>运行后即可获得flag：</p><p><img src="/image/buuctfday1/20.png"></p><h2 id="7-第五空间2019决赛-PWN5"><a href="#7-第五空间2019决赛-PWN5" class="headerlink" title="7. 第五空间2019决赛 PWN5"></a>7. 第五空间2019决赛 PWN5</h2><p><strong>解题步骤</strong>：</p><ul><li>checksec后发现与之前截然不同的结果：有canary保护</li><li>需要想办法绕过canary保护</li><li>查看main函数：</li></ul><p><img src="/image/buuctfday1/21.png"></p><p>发现它先生成一个随机数（4字节），如果输入与随机数相同，即可获得flag。可以发现read可以栈溢出，可以通过栈溢出改变随机数从而通过if函数，这就要绕过canary保护。</p><p><strong>Canary保护原理</strong>：是一种用于防护栈溢出的安全机制。其基本原理是在函数调用时，在栈帧的上方放入一个随机值（称为”Canary”），当函数返回时，系统会检查这个随机值是否被修改。如果随机值被修改，说明可能发生了栈溢出，程序将终止运行，从而防止潜在的缓冲区溢出攻击。</p><ul><li>找到canary的偏移量：</li></ul><p><img src="/image/buuctfday1/22.png"></p><ul><li>编写exp：</li></ul><p><img src="/image/buuctfday1/23.png"></p><p>注：特别要注意的是<code>%n</code>这个格式化字符串，它的功能是将<code>%n</code>之前打印出来的字符个数（四字节）写入参数地址处（赋值给一个变量）。</p><ul><li>运行后即可获得flag：</li></ul><p><img src="/image/buuctfday1/24.png"></p><h2 id="8-jarvisoj-level2"><a href="#8-jarvisoj-level2" class="headerlink" title="8. jarvisoj_level2"></a>8. jarvisoj_level2</h2><p><strong>解题步骤</strong>：</p><ul><li>同样的步骤之后查看main函数：</li></ul><p><img src="/image/buuctfday1/25.png"></p><p>发现明显栈溢出。但发现system函数调用和<code>/bin/sh</code>是分隔的。于是要把它们连接。</p><p>注：32位的分布是：返回地址+下一次的返回地址+参数1+参数2+…，这里返回地址可以随便指定。</p><ul><li>编写exp：</li></ul><p><img src="/image/buuctfday1/26.png"></p><p>运行后即可获得flag。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2libc</title>
    <link href="/2025/10/04/ret2libc/"/>
    <url>/2025/10/04/ret2libc/</url>
    
    <content type="html"><![CDATA[<h1 id="ret2libc技术总结"><a href="#ret2libc技术总结" class="headerlink" title="ret2libc技术总结"></a>ret2libc技术总结</h1><h2 id="1-32位与64位程序函数传参差异"><a href="#1-32位与64位程序函数传参差异" class="headerlink" title="1. 32位与64位程序函数传参差异"></a>1. 32位与64位程序函数传参差异</h2><h3 id="1-1-32位程序传参方式"><a href="#1-1-32位程序传参方式" class="headerlink" title="1.1 32位程序传参方式"></a>1.1 32位程序传参方式</h3><ul><li><strong>传参方式</strong>：通过栈传参，属于后传参</li><li><strong>典型payload结构</strong>：<br>p32(puts_plt) + p32(main_addr) + p32(puts_got)</li></ul><h3 id="1-2-64位程序传参方式"><a href="#1-2-64位程序传参方式" class="headerlink" title="1.2 64位程序传参方式"></a>1.2 64位程序传参方式</h3><ul><li><strong>传参方式</strong>：通过寄存器传参，参数从左到右依次放入寄存器：rdi, rsi, rdx, rcx, r8, r9</li><li><strong>典型payload结构</strong>：<br>p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</li></ul><h2 id="2-Write函数在ret2libc中的应用"><a href="#2-Write函数在ret2libc中的应用" class="headerlink" title="2. Write函数在ret2libc中的应用"></a>2. Write函数在ret2libc中的应用</h2><h3 id="2-1-Write函数参数说明"><a href="#2-1-Write函数参数说明" class="headerlink" title="2.1 Write函数参数说明"></a>2.1 Write函数参数说明</h3><ul><li><strong>第一个参数</strong>：文件描述符（0-标准输入，1-标准输出，2-标准错误）</li><li><strong>第二个参数</strong>：要泄露地址的函数的GOT表</li><li><strong>第三个参数</strong>：输出的字节数（32位为4字节，64位为8字节）</li></ul><h3 id="2-2-32位Write函数传参"><a href="#2-2-32位Write函数传参" class="headerlink" title="2.2 32位Write函数传参"></a>2.2 32位Write函数传参</h3><p>p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)</p><h3 id="2-3-64位Write函数传参"><a href="#2-3-64位Write函数传参" class="headerlink" title="2.3 64位Write函数传参"></a>2.3 64位Write函数传参</h3><p>p64(rdi_addr) + p64(1) + p64(rsi_addr) + p64(write_got) + p64(rdx_addr) + p64(8) + p64(write_plt) + p64(main_addr)</p><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><ol><li><strong>参数复用</strong>：传参时有时可以直接利用程序中已有的参数，避免额外构造</li><li><strong>第三个参数灵活性</strong>：当第三个参数由rsi与其他寄存器一起出现时，可以适当简化</li><li><strong>输出描述符选择</strong>：标准输出(1)和标准错误(2)都可以用作write函数的第一个参数</li><li><strong>寄存器使用顺序</strong>：64位系统中必须严格按照rdi→rsi→rdx→rcx→r8→r9的顺序传参</li></ol><h2 id="4-技术要点"><a href="#4-技术要点" class="headerlink" title="4. 技术要点"></a>4. 技术要点</h2><ul><li>正确识别目标程序的位数（32位&#x2F;64位）</li><li>准确获取所需函数的PLT和GOT表地址  </li><li>合理构造ROP链，确保参数传递正确</li><li>注意栈对齐和函数调用约定</li></ul>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canary绕过</title>
    <link href="/2025/10/03/canary%E7%BB%95%E8%BF%87/"/>
    <url>/2025/10/03/canary%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<p><strong>1.通过确认偏移(偏移&#x3D;变量自身偏移+变量到canary的偏移)来利用输出函数达到泄露canary的值：</strong><br>(1).64位：%n$p<br>(2).32位：%n$x<br><strong>注意：%n$p是泄露偏移为n的栈上的数据，%n$s是泄露偏移为n的栈上的地址的值(该偏移对应的栈上的数据必须是地址)。</strong></p><p><strong>2.通过溢出来利用输出函数泄露canary的值：</strong><br>**(1).**payload&#x3D;b’a’*offset+b’b’*0x1(注意send送，因为sendline会多发一个\n)<br>p.recvuntil(b’b’)<br>32位：canary&#x3D;u32(p.recv(3).rjust(4,b’\x00’))<br>64位：canary&#x3D;u64(p.recv(7).rjust(8,b’\x00’))</p><p>**(2).**利用sendline的特性：<br>payload&#x3D;b’a’*offset(注意用sendline发送)<br>p.recvuntil(b’a’*offset)<br>canary&#x3D;u32(p.recv(4))-0xa(减0xa是为了把sendline发送的换行符\n减掉)</p><p><strong>利用gdb调试</strong><br>**1.**随便在canary设置完的地方下断点<br>**2.**输入canary查找canary的值以及所在地址<br>**3.**stack 50找到该地址，计算偏移：<br><img src="/image/canary1.png" alt="gdb调试寻找偏移"></p><p>因为是六十四位文件所以他格式化字符串时候前六个参数是在寄存器中的而栈空间这个记录的第一个偏移其实是真实的第七个数据单元所以这边算出来还要再加6，即为canary值。<br>上图偏移就为184&#x2F;8&#x3D;23。23+6&#x3D;29。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
